# 객체지향 프로그래밍

객체지향 프로그래밍은 실세계에 존재하고 인지하고 있는 객체를 소프트웨어의 세계에서 표현하기 위해 객체의 핵심적인 개념 또는 기능만을 추출하는 추상화를 통해 모델링하려는 프로그래밍 패러다임이다.

## 용어

### 클래스

객체지향 프로그래밍에서 특정 개체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀.

### 객체

구현할 대상

### 인스턴스

구현된 구체적인 실체

### 객체 vs 인스턴스

- 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
- 객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.

<br/>

## 특징

### 추상화

추상화란 필요로 하는 속성이나 행동을 추출하는 작업으로 <br/>
세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것을 말한다.

### 캡슐화

클래스의 내부 변수와 메소드를 하나로 묶고 구현 내용을 외부에 감추어 은닉한다.

캡슐화의 중요한 목적은 변수를 private로 선언하여 데이터를 보호하고, 보호된 변수는 `getter`나 `setter` 등의 메소드를 통해서만 간접적으로 접근을 허용하는 것이다. => <b>정보 은닉 가능</b>

### 상속

기존 상위 클래스의 기능을 가져와 재사용할 수 있으면서 동시에 새로운 하위 클래스에 새로운 기능도 추가할 수 것을 말한다.

❗ 상속을 사용하여 코드의 중복을 제거할 수 있다.

### 다형성

상속과 연관있는 개념으로 한 객체가 상속을 통해 기능을 확장하거나 변경하여 다른 객체로 재구성 되는 것을 말한다.

- 오버로딩(Overloading)
  하나의 클래스 안에서 같은 이름의 메소드를 사용하여 각기 다른 용도로 사용되며 그 결과 또한 다른게 구현하는 것을 말하며, 메소드끼리 이름은 같지만 매개변수의 개수나 데이터 타입이 달라야한다.
- 오버라이딩(Overriding)
  하위 클래스가 상위 클래스에서 만들어진 메소드를 다시 재창조하여 사용하는 것을 말한다.

👉 다형성을 사용하면 같은 이름의 속성을 유지함으로써, 속성을 사용하기 위한 인터페이스를 유지하고, 메소드 이름을 낭비하지 않는다.

<br/>

## 객체지향 설계 원칙 | SOLID

### SRP (Single Responsibility) - 단일 책임 원칙

클래스는 단 한 개의 책임을 가져야 한다.

### OCP (Open-Closed) - 개방-폐쇄 원칙

확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다. <br/>
즉, 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.

### LSP (Liskov Substitution) - 리스코프 치환 원칙

상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. <br/>
즉, 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있도록 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.

### ISP (Interface Segregation) - 인터페이스 분리 원칙

인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. <br/>
각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.

### DIP (Dependency Inversion) - 의존 역전 원칙

고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. <br/>
즉, 저수준 모듈이 변경되더라도 고수준 모듈은 변경할 필요가 없어야 한다.
